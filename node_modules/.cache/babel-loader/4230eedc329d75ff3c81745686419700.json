{"ast":null,"code":"import isSubset from '../../utils/isSubset';\nimport logger from \"../../utils/logger\";\nimport selectionLevel from '../../api-utils/selectionLevel';\nimport success from '../../api-utils/success';\nimport error from '../../api-utils/error';\nimport showUserErrors from '../../api-utils/showUserErrors';\nexport default function deleteIt() {\n  return new Promise((resolve, reject) => {\n    // delete database\n    this.deleteDatabase = () => {\n      let dbName = this.dbName;\n      indexedDB.deleteDatabase(dbName);\n      resolve(success.call(this, `Database \"${dbName}\" deleted.`, {\n        database: dbName\n      }));\n    }; // delete collection\n\n\n    this.deleteCollection = () => {\n      let dbName = this.dbName;\n      let collectionName = this.collectionName; // we can only delete one collection at a time, which is why we need a queue\n\n      this.addToDeleteCollectionQueue = collectionName => {\n        this.deleteCollectionQueue.queue.push(collectionName);\n        this.runDeleteCollectionQueue();\n      };\n\n      this.runDeleteCollectionQueue = () => {\n        if (this.deleteCollectionQueue.running == false) {\n          this.deleteCollectionQueue.running = true;\n          this.deleteNextCollectionFromQueue();\n        }\n      };\n\n      this.deleteNextCollectionFromQueue = () => {\n        if (this.deleteCollectionQueue.queue.length) {\n          let collectionToDelete = this.deleteCollectionQueue.queue[0];\n          this.deleteCollectionQueue.queue.shift();\n          this.lf[collectionToDelete].dropInstance({\n            name: dbName,\n            storeName: collectionToDelete\n          }).then(() => {\n            this.deleteNextCollectionFromQueue();\n            resolve(success.call(this, `Collection \"${collectionToDelete}\" deleted.`, {\n              collection: collectionToDelete\n            }));\n          }).catch(error => {\n            reject(error.call(this, `Collection \"${collectionToDelete}\" could not be deleted.`));\n          });\n        } else {\n          this.deleteCollectionQueue.running = false;\n        }\n      };\n\n      this.addToDeleteCollectionQueue(collectionName);\n    }; // delete document\n\n\n    this.deleteDocument = () => {\n      let collectionName = this.collectionName;\n      let docSelectionCriteria = this.docSelectionCriteria; // delete document by criteria\n\n      this.deleteDocumentByCriteria = () => {\n        let keysForDeletion = [];\n        this.lf[collectionName].iterate((value, key) => {\n          if (isSubset(value, docSelectionCriteria)) {\n            keysForDeletion.push(key);\n          }\n        }).then(() => {\n          if (!keysForDeletion.length) {\n            reject(error.call(this, `No Documents found in \"${collectionName}\" Collection with criteria ${JSON.stringify(docSelectionCriteria)}. No documents deleted.`));\n          }\n\n          if (keysForDeletion.length > 1) {\n            logger.warn.call(this, `Multiple documents (${keysForDeletion.length}) with ${JSON.stringify(docSelectionCriteria)} found.`);\n          }\n        }).then(() => {\n          keysForDeletion.forEach((key, index) => {\n            this.lf[collectionName].removeItem(key).then(() => {\n              if (index === keysForDeletion.length - 1) {\n                resolve(success.call(this, `${keysForDeletion.length} Document${keysForDeletion.length > 1 ? 's' : ''} with ${JSON.stringify(docSelectionCriteria)} deleted.`, {\n                  keys: keysForDeletion\n                }));\n              }\n            }).catch(err => {\n              reject(error.call(this, `Could not delete ${keysForDeletion.length} Documents in ${collectionName} Collection.`));\n            });\n          });\n        });\n      }; // delete document by key\n\n\n      this.deleteDocumentByKey = () => {\n        this.lf[collectionName].getItem(docSelectionCriteria).then(value => {\n          if (value) {\n            this.lf[collectionName].removeItem(docSelectionCriteria).then(() => {\n              resolve(success.call(this, `Document with key ${JSON.stringify(docSelectionCriteria)} deleted.`, {\n                key: docSelectionCriteria\n              }));\n            }).catch(function (err) {\n              reject(error.call(this, `No Document found in \"${collectionName}\" Collection with key ${JSON.stringify(docSelectionCriteria)}. No document was deleted.`));\n            });\n          } else {\n            reject(error.call(this, `No Document found in \"${collectionName}\" Collection with key ${JSON.stringify(docSelectionCriteria)}. No document was deleted.`));\n          }\n        });\n      };\n\n      if (typeof docSelectionCriteria == 'object') {\n        return this.deleteDocumentByCriteria();\n      } else {\n        return this.deleteDocumentByKey();\n      }\n    };\n\n    if (!this.userErrors.length) {\n      let currentSelectionLevel = selectionLevel.call(this);\n\n      if (currentSelectionLevel == 'db') {\n        return this.deleteDatabase();\n      } else if (currentSelectionLevel == 'collection') {\n        return this.deleteCollection();\n      } else if (currentSelectionLevel == 'doc') {\n        return this.deleteDocument();\n      }\n    } else {\n      showUserErrors.call(this);\n    }\n  });\n}","map":{"version":3,"sources":["/Users/constantine/Dev/FrontEnd/progress/node_modules/localbase/localbase/api/actions/delete.js"],"names":["isSubset","logger","selectionLevel","success","error","showUserErrors","deleteIt","Promise","resolve","reject","deleteDatabase","dbName","indexedDB","call","database","deleteCollection","collectionName","addToDeleteCollectionQueue","deleteCollectionQueue","queue","push","runDeleteCollectionQueue","running","deleteNextCollectionFromQueue","length","collectionToDelete","shift","lf","dropInstance","name","storeName","then","collection","catch","deleteDocument","docSelectionCriteria","deleteDocumentByCriteria","keysForDeletion","iterate","value","key","JSON","stringify","warn","forEach","index","removeItem","keys","err","deleteDocumentByKey","getItem","userErrors","currentSelectionLevel"],"mappings":"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","sourcesContent":["import isSubset from '../../utils/isSubset'\nimport logger from \"../../utils/logger\"\nimport selectionLevel from '../../api-utils/selectionLevel'\nimport success from '../../api-utils/success'\nimport error from '../../api-utils/error'\nimport showUserErrors from '../../api-utils/showUserErrors'\n\nexport default function deleteIt() {\n\n  return new Promise((resolve, reject) => {\n\n    // delete database\n    this.deleteDatabase = () => {\n      let dbName = this.dbName\n\n      indexedDB.deleteDatabase(dbName)\n      resolve(\n        success.call(\n          this,\n          `Database \"${ dbName }\" deleted.`,\n          { database: dbName }\n        )\n      )\n    }\n\n    // delete collection\n    this.deleteCollection = () => {\n      let dbName = this.dbName\n      let collectionName = this.collectionName\n\n      // we can only delete one collection at a time, which is why we need a queue\n\n      this.addToDeleteCollectionQueue = (collectionName) => {\n        this.deleteCollectionQueue.queue.push(collectionName)\n        this.runDeleteCollectionQueue()\n      }\n\n      this.runDeleteCollectionQueue = () => {\n        if (this.deleteCollectionQueue.running == false) {\n          this.deleteCollectionQueue.running = true\n          this.deleteNextCollectionFromQueue()\n        }\n      }\n\n      this.deleteNextCollectionFromQueue = () => {\n        if (this.deleteCollectionQueue.queue.length) {\n          let collectionToDelete = this.deleteCollectionQueue.queue[0]\n          this.deleteCollectionQueue.queue.shift()\n\n          this.lf[collectionToDelete].dropInstance({\n            name        : dbName,\n            storeName   : collectionToDelete\n          }).then(() => {\n            this.deleteNextCollectionFromQueue()\n            resolve(\n              success.call(\n                this,\n                `Collection \"${ collectionToDelete }\" deleted.`,\n                { collection: collectionToDelete }\n              )\n            )\n          }).catch(error => {\n            reject(\n              error.call(\n                this,\n                `Collection \"${ collectionToDelete }\" could not be deleted.`\n              )\n            )\n          })\n        }\n        else {\n          this.deleteCollectionQueue.running = false\n        }\n      }\n\n      this.addToDeleteCollectionQueue(collectionName)\n    }\n\n    // delete document\n    this.deleteDocument = () => {\n\n      let collectionName = this.collectionName\n      let docSelectionCriteria = this.docSelectionCriteria\n\n      // delete document by criteria\n      this.deleteDocumentByCriteria = () => {\n        let keysForDeletion = []\n        this.lf[collectionName].iterate((value, key) => {\n          if (isSubset(value, docSelectionCriteria)) {\n            keysForDeletion.push(key)\n          }\n        }).then(() => {\n          if (!keysForDeletion.length) {\n            reject(\n              error.call(\n                this,\n                `No Documents found in \"${ collectionName }\" Collection with criteria ${ JSON.stringify(docSelectionCriteria) }. No documents deleted.`\n              )\n            )\n          }\n          if (keysForDeletion.length > 1) {\n            logger.warn.call(this, `Multiple documents (${ keysForDeletion.length }) with ${ JSON.stringify(docSelectionCriteria) } found.`)\n          }\n        }).then(() => {\n          keysForDeletion.forEach((key, index) => {\n            this.lf[collectionName].removeItem(key).then(() => {\n              if (index === (keysForDeletion.length - 1)) {\n                resolve(\n                  success.call(\n                    this,\n                    `${ keysForDeletion.length } Document${ keysForDeletion.length > 1 ? 's' : '' } with ${ JSON.stringify(docSelectionCriteria) } deleted.`,\n                    { keys: keysForDeletion }\n                  )\n                )\n              }\n            }).catch(err => {\n              reject(\n                error.call(\n                  this,\n                  `Could not delete ${ keysForDeletion.length } Documents in ${ collectionName } Collection.`\n                )\n              )\n            })\n          })\n        })\n      }\n\n      // delete document by key\n      this.deleteDocumentByKey = () => {\n        this.lf[collectionName].getItem(docSelectionCriteria).then(value => {\n          if (value) {\n            this.lf[collectionName].removeItem(docSelectionCriteria).then(() => {\n              resolve(\n                success.call(\n                  this,\n                  `Document with key ${ JSON.stringify(docSelectionCriteria) } deleted.`,\n                  { key: docSelectionCriteria }\n                )\n              )\n            }).catch(function(err) {\n              reject(\n                error.call(\n                  this,\n                  `No Document found in \"${ collectionName }\" Collection with key ${ JSON.stringify(docSelectionCriteria) }. No document was deleted.`\n                )\n              )\n            });\n          }\n          else {\n            reject(\n              error.call(\n                this,\n                `No Document found in \"${ collectionName }\" Collection with key ${ JSON.stringify(docSelectionCriteria) }. No document was deleted.`\n              )\n            )\n          }\n        });\n\n      }\n\n      if (typeof docSelectionCriteria == 'object') {\n        return this.deleteDocumentByCriteria()\n      }\n      else {\n        return this.deleteDocumentByKey()\n      }\n    }\n    \n    if (!this.userErrors.length) {\n      let currentSelectionLevel = selectionLevel.call(this)\n  \n      if (currentSelectionLevel == 'db') {\n        return this.deleteDatabase()\n      }\n      else if (currentSelectionLevel == 'collection') {\n        return this.deleteCollection()\n      }\n      else if (currentSelectionLevel == 'doc') {\n        return this.deleteDocument()\n      }\n    }\n    else {\n      showUserErrors.call(this)\n    }\n\n  })\n\n}"]},"metadata":{},"sourceType":"module"}